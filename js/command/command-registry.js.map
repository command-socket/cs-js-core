{"version":3,"sources":["ts/command/command-registry.ts"],"names":["command_socket_command_not_found_error_1","require","CommandRegistry","[object Object]","commands","this","commandMap","Map","addCommands","command","set","getName","has","get","params","context","hasCommand","execute","CommandSocketCommandNotFoundError","exports"],"mappings":"4YAQA,MAAAA,yCAAAC,QAAA,mDAUA,MAAaC,gBAIZC,eAAsBC,GAErBC,KAAKC,WAAa,IAAIC,IAEtBF,KAAKG,eAAeJ,GAIdD,eAAeC,GAErB,IAAK,IAAIK,KAAWL,EAAUC,KAAKC,WAAWI,IAAID,EAAQE,UAAuBF,GAI3EN,WAAWM,GAEjB,OAAOJ,KAAKC,WAAWM,IAAIH,GAIrBN,WAA0CM,GAEhD,OAAOJ,KAAKC,WAAWO,IAAIJ,GAIfN,QACZM,EAAYK,EAAyBC,oDAGrC,GAAIV,KAAKW,WAAWP,GAGnB,aAAcJ,KAAKC,WAAWO,IAAIJ,GAAuCQ,QAAQH,EAAQC,GAEnF,MAAM,IAAIf,yCAAAkB,kCAAkCT,OAvCrDU,QAAAjB,gBAAAA","file":"command-registry.js","sourcesContent":["/*\n *\tCreated by Trevor Sears <trevorsears.main@gmail.com>.\n *\t3:36 PM -- October 21st, 2019.\n *\tProject: @command-socket/core\n */\n\nimport { Command } from \"./command\";\nimport { CommandSetStructure } from \"../schema/command-set-structure\";\nimport { CommandSocketCommandNotFoundError } from \"../error/command-socket-command-not-found-error\";\nimport { CommandSocket } from \"../command-socket/command-socket\";\n\n/**\n * A registry of commands, accessible via their names.\n *\n * @author Trevor Sears <trevorsears.main@gmail.com>\n * @version v0.1.0\n * @since v0.1.0\n */\nexport class CommandRegistry<CS extends CommandSetStructure = any> {\n\t\n\tprivate commandMap: Map<keyof CS, Command<CS[keyof CS]>>;\n\t\n\tpublic constructor(...commands: Array<Command<CS[keyof CS]>>) {\n\t\n\t\tthis.commandMap = new Map<keyof CS, Command<CS[keyof CS]>>();\n\t\t\n\t\tthis.addCommands(...commands);\n\t\n\t}\n\t\n\tpublic addCommands(...commands: Array<Command<CS[keyof CS]>>): void {\n\t\t\n\t\tfor (let command of commands) this.commandMap.set(command.getName() as keyof CS, command);\n\t\t\n\t}\n\t\n\tpublic hasCommand(command: string): boolean {\n\t\t\n\t\treturn this.commandMap.has(command as keyof CS);\n\t\t\n\t}\n\t\n\tpublic getCommand<C extends keyof CS = keyof CS>(command: C): Command<CS[C]> | undefined {\n\t\t\n\t\treturn this.commandMap.get(command) as Command<CS[C]> | undefined;\n\t\t\n\t}\n\t\n\tpublic async execute<C extends keyof CS = keyof CS>(\n\t\tcommand: C, params: CS[C][\"params\"], context: CommandSocket<any, any>):\n\t\tPromise<CS[C][\"return\"]> {\n\t\t\n\t\tif (this.hasCommand(command as string)) {\n\t\t\t\n\t\t\t// FIX-ME [11/26/19 @ 2:02 AM] - This is not a correct fix.\n\t\t\treturn await (this.commandMap.get(command) as unknown as Command<CS[C]>).execute(params, context);\n\t\t\t\n\t\t} else throw new CommandSocketCommandNotFoundError(command as string);\n\t\t\n\t}\n\t\n}"]}