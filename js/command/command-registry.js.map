{"version":3,"sources":["ts/command/command-registry.ts"],"names":["command_socket_command_not_found_error_1","require","CommandRegistry","[object Object]","commands","this","commandMap","Map","addCommands","command","set","getName","commandName","implementation","execute","has","get","params","context","hasCommand","CommandSocketCommandNotFoundError","exports"],"mappings":"4YAOA,MAAAA,yCAAAC,QAAA,mDAoBA,MAAaC,gBAYZC,eAAsBC,GAErBC,KAAKC,WAAa,IAAIC,IAEtBF,KAAKG,eAAeJ,GASdD,eAAeC,GAIrB,IAAK,IAAIK,KAAWL,EAEnBC,KAAKC,WAAWI,IAAID,EAAQE,UAAWF,GAOlCN,iBACNS,EAA0BC,GAE1B,IAAIJ,EAAoD,IAAI,MAAAN,cAEpDE,KAAAM,QAA6B,IAAmBC,EAEhDP,KAAAS,QAAwDD,IAIhER,KAAKG,YAAYC,GAUXN,WAAWM,GAEjB,OAAOJ,KAAKC,WAAWS,IAAIN,GAarBN,WAAqFM,GAG3F,OAAOJ,KAAKC,WAAWU,IAAIP,GAKfN,QACZS,EAA0BK,EAC1BC,oDAGA,GAAIb,KAAKc,WAAWP,GAAwB,CAE3C,IAAIH,EACHJ,KAAKC,WAAWU,IAAIJ,GAErB,aAAcH,EAAQK,QAAQG,EAAQC,GAGhC,MAAM,IAAIlB,yCAAAoB,kCAAkCR,OA/FrDS,QAAAnB,gBAAAA","file":"command-registry.js","sourcesContent":["/*\n *\tCreated by Trevor Sears <trevorsears.main@gmail.com>.\n *\t3:36 PM -- October 21st, 2019.\n *\tProject: @command-socket/core\n */\n\nimport { Command } from \"./command\";\nimport { CommandSocketCommandNotFoundError } from \"../error/command-socket-command-not-found-error\";\nimport { CommandSocket } from \"../command-socket/command-socket\";\nimport { CommandInCommandSet, CommandNameInCommandSet, CommandSetStructure } from \"../schema/command-set-structure\";\nimport { IfAny } from \"../util/any-types\";\nimport {\n\tCommandStructureParameterType,\n\tCommandStructureReturnType\n} from \"../schema/command-structure\";\n\ntype ExecuteFunctionType<CS extends CommandSetStructure, CN extends keyof CS> =\n\t(params: CommandStructureParameterType<CommandInCommandSet<CS, CN>>,\n\t context: CommandSocket) => Promise<CommandStructureReturnType<CommandInCommandSet<CS, CN>>>;\n\n/**\n * A registry of {@link Command}s, accessible via their string identifiers.\n *\n * @author Trevor Sears <trevorsears.main@gmail.com>\n * @version v0.1.0\n * @since v0.1.0\n */\nexport class CommandRegistry<CommandSet extends CommandSetStructure = any> {\n\t\n\t/**\n\t * A map from {@link Command} identifiers to Commands.\n\t */\n\tprivate commandMap: Map<string, Command<any>>;\n\t\n\t/**\n\t * Initializes a new CommandRegistry with the provided list of {@link Command}s.\n\t *\n\t * @param commands The array of Commands to include in the newly initialized CommandRegistry.\n\t */\n\tpublic constructor(...commands: Array<Command<CommandInCommandSet<CommandSet>>>) {\n\t\n\t\tthis.commandMap = new Map();\n\t\t\n\t\tthis.addCommands(...commands);\n\t\n\t}\n\t\n\t/**\n\t * Adds one or more {@link Command}s to this CommandRegistry instance.\n\t *\n\t * @param commands The Command(s) to add to this CommandRegistry instance.\n\t */\n\tpublic addCommands(...commands: Array<Command<CommandInCommandSet<CommandSet>>>): void {\n\t\t\n\t\t// TODO [1/16/20 @ 8:25 AM] - Add in handling for erroring on duplicated command names.\n\t\t\n\t\tfor (let command of commands) {\n\t\t\t\n\t\t\tthis.commandMap.set(command.getName(), command);\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n\t// DOC-ME [2/21/20 @ 9:55 PM] - Documentation required!\n\tpublic addInlineCommand<CommandName extends IfAny<CommandSet, string, CommandNameInCommandSet<CommandSet>>>(\n\t\tcommandName: CommandName, implementation: ExecuteFunctionType<CommandSet, CommandName>): void {\n\t\t\n\t\tlet command: Command<CommandInCommandSet<CommandSet>> = new class {\n\t\t\t\n\t\t\tpublic getName: () => CommandName = (): CommandName => commandName;\n\t\t\t\n\t\t\tpublic execute: ExecuteFunctionType<CommandSet, CommandName> = implementation;\n\t\t\t\n\t\t} as unknown as Command<CommandInCommandSet<CommandSet>>;\n\t\t\n\t\tthis.addCommands(command);\n\t\t\n\t}\n\t\n\t/**\n\t * Returns true if this CommandRegistry instance contains a {@link Command} with the provided identifier.\n\t *\n\t * @param command The string Command identifier to check for existence within this CommandRegistry instance.\n\t * @return true if this CommandRegistry instance contains a Command with the provided identifier.\n\t */\n\tpublic hasCommand(command: string): boolean {\n\t\t\n\t\treturn this.commandMap.has(command);\n\t\t\n\t}\n\t\n\t/**\n\t * Returns the {@link Command} associated with the provided Command identifier if such a Command exists, otherwise\n\t * returning undefined.\n\t *\n\t * @param command The string Command identifier for which to return a Command.\n\t * @return The Command associated with the provided Command identifier if such a Command exists, otherwise returning\n\t * undefined.\n\t * @see CommandRegistry#hasCommand\n\t */\n\tpublic getCommand<C extends IfAny<CommandSet, string, CommandNameInCommandSet<CommandSet>>>(command: C):\n\t\tIfAny<CommandSet, Command<any>, Command<CommandSet[C]>> {\n\t\t\n\t\treturn this.commandMap.get(command as string) as (IfAny<CommandSet, Command<any>, Command<CommandSet[C]>>);\n\t\t\n\t}\n\t\n\t// DOC-ME [1/13/20 @ 12:37 PM] - Documentation required!\n\tpublic async execute<CommandName extends IfAny<CommandSet, string, CommandNameInCommandSet<CommandSet>>>(\n\t\tcommandName: CommandName, params: CommandStructureParameterType<CommandInCommandSet<CommandSet, CommandName>>,\n\t\tcontext: CommandSocket):\n\t\tPromise<IfAny<CommandSet, any, CommandStructureReturnType<CommandInCommandSet<CommandSet, CommandName>>>> {\n\t\t\n\t\tif (this.hasCommand(commandName as string)) {\n\t\t\t\n\t\t\tlet command: Command<CommandSet[CommandName]> =\n\t\t\t\tthis.commandMap.get(commandName as string) as Command<CommandSet[CommandName]>;\n\t\t\t\n\t\t\treturn (await command.execute(params, context)) as unknown as\n\t\t\t\tIfAny<CommandSet, any, CommandStructureReturnType<CommandSet[CommandName]>>;\n\t\t\t\n\t\t} else throw new CommandSocketCommandNotFoundError(commandName as string);\n\t\t\n\t}\n\t\n}"]}