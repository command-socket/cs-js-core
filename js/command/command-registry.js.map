{"version":3,"sources":["ts/command/command-registry.ts"],"names":["command_socket_command_not_found_error_1","require","CommandRegistry","[object Object]","this","commandMap","Map","command","execute","commandName","set","normalizeCommand","has","get","params","context","hasCommand","CommandSocketCommandNotFoundError","exports"],"mappings":"4YAMA,MAAAA,yCAAAC,QAAA,mDAwBA,MAAaC,gBAUZC,cAECC,KAAKC,WAAa,IAAIC,IAKbH,wBACTI,GAEA,MAAuB,mBAAZA,EAA+BA,EAC9BA,EAAQC,QAKdL,WACNM,EAA0BF,GAI1BH,KAAKC,WAAWK,IAAID,EAAaP,gBAAgBS,iBAA6BJ,IAUxEJ,WAAWI,GAEjB,OAAOH,KAAKC,WAAWO,IAAIL,GAarBJ,WAAoEI,GAG1E,OAAOH,KAAKC,WAAWQ,IAAIN,GAMfJ,QACZM,EAA0BK,EAC1BC,oDAGA,GAAIX,KAAKY,WAAWP,GAAwB,CAE3C,IAAIF,EACHH,KAAKC,WAAWQ,IAAIJ,GAErB,aAAaF,EAAQO,EAAQC,GAEvB,MAAM,IAAIf,yCAAAiB,kCAAkCR,OA7ErDS,QAAAhB,gBAAAA","file":"command-registry.js","sourcesContent":["/*\n *\tCreated by Trevor Sears <trevorsears.main@gmail.com>.\n *\t3:36 PM -- October 21st, 2019.\n *\tProject: @command-socket/core\n */\n\nimport { CommandSocketCommandNotFoundError } from \"../error/command-socket-command-not-found-error\";\nimport { CommandSocket } from \"../command-socket/command-socket\";\nimport { CommandStructureInCommandSet, CommandNameInCommandSet, CommandSetStructure } from \"../schema/command/command-set-structure\";\nimport { IfAny } from \"../util/any-types\";\nimport {\n\tCommandStructureParameterType,\n\tCommandStructureReturnType\n} from \"../schema/command/command-structure\";\nimport { CommandExecutableFunction } from \"../schema/command/command-executable-function\";\nimport { Command } from \"../schema/command/command\";\n\ntype CommandMapKey<CommandSet extends CommandSetStructure> = CommandNameInCommandSet<CommandSet>;\n\ntype CommandMapValue<CommandSet extends CommandSetStructure,\n\tCommandName extends CommandNameInCommandSet<CommandSet> = CommandNameInCommandSet<CommandSet>> =\n\tCommandExecutableFunction<CommandStructureInCommandSet<CommandSet, CommandName>>;\n\n/**\n * A registry of {@link Command}s, accessible via their string identifiers.\n *\n * @author Trevor Sears <trevorsears.main@gmail.com>\n * @version v0.1.0\n * @since v0.1.0\n */\nexport class CommandRegistry<CommandSet extends CommandSetStructure = any> {\n\t\n\t/**\n\t * A map from Command identifiers to {@link Command}s.\n\t */\n\tprivate commandMap: Map<CommandMapKey<CommandSet>, CommandMapValue<CommandSet>>;\n\t\n\t/**\n\t * Initializes a new CommandRegistry.\n\t */\n\tpublic constructor() {\n\t\n\t\tthis.commandMap = new Map();\n\t\n\t}\n\t\n\t// DOC-ME [2/22/20 @ 1:55 PM] - Documentation required!\n\tprotected static normalizeCommand<CommandSet extends CommandSetStructure>(\n\t\tcommand: Command<CommandStructureInCommandSet<CommandSet>>): CommandExecutableFunction<CommandStructureInCommandSet<CommandSet>> {\n\t\t\n\t\tif (typeof command === \"function\") return command;\n\t\telse return command.execute;\n\t\t\n\t}\n\t\n\t// DOC-ME [2/22/20 @ 2:59 PM] - Documentation required!\n\tpublic addCommand<CommandName extends CommandNameInCommandSet<CommandSet>>(\n\t\tcommandName: CommandName, command: Command<CommandStructureInCommandSet<CommandSet, CommandName>>): void {\n\t\t\n\t\t// TODO [1/16/20 @ 8:25 AM] - Add in handling for erroring on duplicated command names.\n\t\t\n\t\tthis.commandMap.set(commandName, CommandRegistry.normalizeCommand<CommandSet>(command));\n\t\t\n\t}\n\t\n\t/**\n\t * Returns true if this CommandRegistry instance contains a {@link Command} with the provided identifier.\n\t *\n\t * @param command The string Command identifier to check for existence within this CommandRegistry instance.\n\t * @return true if this CommandRegistry instance contains a Command with the provided identifier.\n\t */\n\tpublic hasCommand(command: string): boolean {\n\t\t\n\t\treturn this.commandMap.has(command as CommandMapKey<CommandSet>);\n\t\t\n\t}\n\t\n\t/**\n\t * Returns the {@link Command} associated with the provided Command identifier if such a Command exists, otherwise\n\t * returning undefined.\n\t *\n\t * @param command The string Command identifier for which to return a Command.\n\t * @return The Command associated with the provided Command identifier if such a Command exists, otherwise returning\n\t * undefined.\n\t * @see CommandRegistry#hasCommand\n\t */\n\tpublic getCommand<CommandName extends CommandNameInCommandSet<CommandSet>>(command: CommandName):\n\t\tIfAny<CommandSet, CommandExecutableFunction<any> | undefined, CommandExecutableFunction<CommandStructureInCommandSet<CommandSet, CommandName>>> {\n\t\t\n\t\treturn this.commandMap.get(command) as\n\t\t\tIfAny<CommandSet, CommandExecutableFunction<any> | undefined, CommandExecutableFunction<CommandStructureInCommandSet<CommandSet, CommandName>>>;\n\t\t\n\t}\n\t\n\t// DOC-ME [1/13/20 @ 12:37 PM] - Documentation required!\n\tpublic async execute<CommandName extends CommandNameInCommandSet<CommandSet>>(\n\t\tcommandName: CommandName, params: CommandStructureParameterType<CommandStructureInCommandSet<CommandSet, CommandName>>,\n\t\tcontext: CommandSocket):\n\t\tPromise<IfAny<CommandSet, any, CommandStructureReturnType<CommandStructureInCommandSet<CommandSet, CommandName>>>> {\n\t\t\n\t\tif (this.hasCommand(commandName as string)) {\n\t\t\t\n\t\t\tlet command: CommandExecutableFunction<CommandStructureInCommandSet<CommandSet, CommandName>> =\n\t\t\t\tthis.commandMap.get(commandName) as CommandExecutableFunction<CommandStructureInCommandSet<CommandSet, CommandName>>;\n\t\t\t\n\t\t\treturn await command(params, context) as unknown as IfAny<CommandSet, any, CommandStructureReturnType<CommandStructureInCommandSet<CommandSet, CommandName>>>;\n\t\t\t\n\t\t} else throw new CommandSocketCommandNotFoundError(commandName as string);\n\t\t\n\t}\n\t\n}"]}