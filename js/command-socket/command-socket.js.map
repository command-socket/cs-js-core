{"version":3,"sources":["ts/command-socket/command-socket.ts"],"names":["typit_1","require","IDUtilities","__importStar","command_registry_1","message_definition_1","command_socket_message_factory_1","command_socket_error_1","command_socket_command_not_found_error_1","command_socket_server_error_1","command_socket_misplaced_response_error_1","identify_command_1","ping_command_1","command_socket_events_1","command_socket_state_1","timed_response_command_1","command_socket_unrequited_request_error_1","CommandSocket","[object Object]","socket","commandRegistry","CommandRegistry","this","id","generateID","ID_LENGTH","state","CommandSocketState","CONNECTING","messageType","ObjectType","MessageDefinition","outstandingRequests","Map","events","CommandSocketEvents","getEvents","OPEN","subscribe","event","notify","source","MESSAGE","handleMessage","data","CLOSE","CLOSED","Object","assign","commandName","BUILTIN_COMMANDS","getCommandRegistry","addCommand","command","params","Promise","resolve","reject","__awaiter","getState","isUsable","request","CommandSocketMessageFactory","createRequestMessage","set","meta","correspondenceID","responseCallback","response","timeReceived","timeline","responseReceived","REQUEST_FULFILLED","delete","OUTGOING_REQUEST","send","JSON","stringify","rawRequest","didError","return","requestSent","timestamp","Date","now","outstandingRequest","values","createResponseMessage","CommandSocketUnrequitedRequestError","clear","close","jsonData","parse","checkConformity","Error","message","mode","handleRequest","handleResponse","exception","INCOMING_REQUEST","hasCommand","returnValue","execute","parameters","CommandSocketCommandNotFoundError","toMessage","error","CommandSocketError","CommandSocketServerError","OUTGOING_RESPONSE","has","get","INCOMING_RESPONSE","console","CommandSocketMisplacedResponseError","getID","ip","getIP","exports","commandsocket identify","IdentifyCommand","commandsocket ping","PingCommand","commandsocket debug timed-response","TimedResponseCommand"],"mappings":"gkBAMA,MAAAA,QAAAC,QAAA,SACAC,YAAAC,aAAAF,QAAA,yBAEAG,mBAAAH,QAAA,+BACAI,qBAAAJ,QAAA,uCAMAK,iCAAAL,QAAA,oDAGAM,uBAAAN,QAAA,iCACAO,yCAAAP,QAAA,mDACAQ,8BAAAR,QAAA,wCACAS,0CAAAT,QAAA,oDAEAU,mBAAAV,QAAA,wCACAW,eAAAX,QAAA,oCACAY,wBAAAZ,QAAA,2BACAa,uBAAAb,QAAA,0BACAc,yBAAAd,QAAA,oDAEAe,0CAAAf,QAAA,oDAkCA,MAAsBgB,cAyCrBC,YAAmBC,EAAiBC,EAAwC,IAAIhB,mBAAAiB,iBAE/EC,KAAKC,GAAKrB,YAAYsB,WAAWP,cAAcQ,WAC/CH,KAAKH,OAASA,EACdG,KAAKI,MAAQZ,uBAAAa,mBAAmBC,WAChCN,KAAKF,gBAAkBA,EACvBE,KAAKO,YAAc,IAAI7B,QAAA8B,WAAW,IAAIzB,qBAAA0B,mBACtCT,KAAKU,oBAAsB,IAAIC,IAC/BX,KAAKY,OAAS,IAAIrB,wBAAAsB,oBAElBb,KAAKH,OAAOiB,YAAYC,KAAKC,UAAWC,IAEvCjB,KAAKI,MAAQZ,uBAAAa,mBAAmBU,KAEhCf,KAAKc,YAAYC,KAAKG,OAAO,CAAEC,OAAQnB,SAOxCA,KAAKH,OAAOiB,YAAYM,QAAQJ,UAAWC,IAE1CjB,KAAKqB,cAAcJ,EAAMK,QAI1BtB,KAAKH,OAAOiB,YAAYS,MAAMP,UAAWC,IAExCjB,KAAKI,MAAQZ,uBAAAa,mBAAmBmB,OAEhCxB,KAAKc,YAAYS,MAAML,OAAMO,OAAAC,OAAAD,OAAAC,OAAA,GAAMT,GAAK,CAAEE,OAAQnB,UAInD,IAAK,IAAI2B,KAAehC,cAAciC,iBAErC5B,KAAK6B,qBAAqBC,WAAWH,EAAoBhC,cAAciC,iBAAiBD,IAkB7E/B,WACZmC,EACAC,oDAQA,OAAO,IAAIC,QAA+B,CAAOC,EAAyDC,IAAiDC,UAAApC,UAAA,OAAA,GAAA,YAGpJA,KAAKqC,WAAWC,YAAYH,EAAO,yDAExC,IAAII,QACGvD,iCAAAwD,4BAA4BC,qBACjCV,EACAC,EACAhC,MAGFA,KAAKU,oBAAoBgC,IACxBH,EAAQI,KAAKC,iBACb,CACCL,QAAAA,EACAM,iBAAkB,CAACC,EAAwGC,KAE1HD,EAASH,KAAKK,SAASC,iBAAmBF,EAE1C/C,KAAKc,YAAYoC,kBAAkBhC,OAAO,CACzCC,OAAQnB,KACRuC,QAAAA,EACAO,SAAAA,IAGD9C,KAAKU,oBAAoByC,OAAOZ,EAAQI,KAAKC,kBAE7CV,EAAQY,MAKX9C,KAAKc,YAAYsC,iBAAiBlC,OAAO,CAAEC,OAAQnB,KAAMuC,QAAAA,IAEzDvC,KAAKH,OAAOwD,KAAKC,KAAKC,UAAUhB,WAetB3C,OACZmC,EAAsBC,oDAItB,IAAIc,QAA+G9C,KAAKwD,WAAWzB,EAASC,GAE5I,GAAIc,EAASH,KAAKc,SAAU,MAAMX,EAASY,OACtC,OAAOZ,EAASY,UAIT9D,wDAGZ,IAAIkD,QACG9C,KAAKwD,WAAW,qBAA6B,SAEpD,OAASV,EAASH,KAAKK,SAASC,iBAA8BH,EAASH,KAAKK,SAASW,eAIzE/D,yDAIZ,IAAIgE,EAAoBC,KAAKC,MAE7B,IAAK,IAAIC,KAAsB/D,KAAKU,oBAAoBsD,SAAU,CAEjE,IAAIlB,QAA+C9D,iCAAAwD,4BAA4ByB,sBAC9EF,EAAmBxB,QACnB,IAAI7C,0CAAAwE,oCACJlE,MACA,EACA4D,GAKDG,EAAmBlB,iBAAiBC,EAAUc,GAI/C5D,KAAKU,oBAAoByD,QAEzBnE,KAAKH,OAAOuE,WAIHxE,cAAc0B,GAEvB,IACI+C,EADAtB,EAAuBc,KAAKC,MAGhC,IAIC,GAFAO,EAAWf,KAAKgB,MAAMhD,IAEjBtB,KAAKO,YAAYgE,gBAAgBF,GASrC,MAAM,IAAIG,MAAM,yBAIjB,IAAIC,EAAgCJ,EAEV,YAAtBI,EAAQ9B,KAAK+B,KAAoB1E,KAAK2E,cAAcF,EAAwC1B,GAC3F/C,KAAK4E,eAAeH,EAAyC1B,GAEjE,MAAO8B,GAGR,MAAM,IAAIL,MAAM,0BAMF5E,cAAc2C,EAAsCQ,oDAEnE,IAAID,EAEJ9C,KAAKc,YAAYgE,iBAAiB5D,OAAO,CAAEC,OAAQnB,KAAMuC,QAAAA,IAEzD,IAEC,GAAIvC,KAAK6B,qBAAqBkD,WAAWxC,EAAQR,SAAU,CAE1D,IAAIiD,QAAyBhF,KAAK6B,qBAAqBoD,QAAQ1C,EAAQR,QAAgBQ,EAAQ2C,WAAmBlF,MAElH8C,QAAiB9D,iCAAAwD,4BAA4ByB,sBAAsB1B,EAASyC,EAAahF,MAAM,EAAO+C,QAEhGD,QAAiB,IAAK5D,yCAAAiG,kCAAkC5C,EAAQR,SAAUqD,UAAU7C,EAASvC,MAEnG,MAAOqF,GAEiCvC,EAArCuC,aAAiBpG,uBAAAqG,yBAAqCD,EAAMD,UAAU7C,EAASvC,YAC7D,IAAKb,8BAAAoG,0BAA4BH,UAAU7C,EAASvC,MAI3EA,KAAKc,YAAY0E,kBAAkBtE,OAAO,CAAEC,OAAQnB,KAAMuC,QAAAA,EAASO,SAAAA,IAEnE9C,KAAKH,OAAOwD,KAAKC,KAAKC,UAAUT,OAIvBlD,eAAekD,EAAwCC,GAEhE,GAAI/C,KAAKU,oBAAoB+E,IAAI3C,EAASH,KAAKC,kBAAmB,CAGjE,IAAImB,EACH/D,KAAKU,oBAAoBgF,IAAI5C,EAASH,KAAKC,kBAG5C5C,KAAKU,oBAAoByC,OAAOL,EAASH,KAAKC,kBAE9C5C,KAAKc,YAAY6E,kBAAkBzE,OAAO,CACzCC,OAAQnB,KACRuC,QAASwB,EAAmBxB,QAC5BO,SAAAA,IAGDiB,EAAmBlB,iBAAiBC,EAAUC,QAK9C6C,QAAQP,MAAM,IAAIjG,0CAAAyG,qCAMbjG,QAEN,OAAOI,KAAKC,GAINL,qBAEN,OAAOI,KAAKF,gBAIAF,qEAEZ,MAAO,CAENK,GAAID,KAAK8F,QACTC,SAAU/F,KAAKH,OAAOmG,YAMjBpG,WAEN,OAAOI,KAAKI,MAINR,YAEN,OAAOI,KAAKY,QA1UdqF,QAAAtG,cAAAA,cAOwBA,cAAAQ,UAAoB,GAKnBR,cAAAiC,iBAAkE,CACzFsE,yBAA0B,IAAI7G,mBAAA8G,gBAC9BC,qBAAsB,IAAI9G,eAAA+G,YAC1BC,qCAAsC,IAAI7G,yBAAA8G","file":"command-socket.js","sourcesContent":["/*\n *\tCreated by Trevor Sears <trevorsears.main@gmail.com>.\n *\t7:51 PM -- September 18th, 2019.\n *\tProject: @command-socket/core\n */\n\nimport { ObjectType } from \"typit\";\nimport * as IDUtilities from \"../util/id-utilities\";\nimport { CommandStructureInCommandSet, CommandNameInCommandSet, CommandSetStructure } from \"../schema/command/command-set-structure\";\nimport { CommandRegistry } from \"../command/command-registry\";\nimport { MessageDefinition } from \"../schema/typing/message-definition\";\nimport {\n\tCommandSocketMessage,\n\tCommandSocketRequestMessage,\n\tCommandSocketResponseMessage\n} from \"../schema/message/command-socket-message\";\nimport { CommandSocketMessageFactory } from \"../schema/message/command-socket-message-factory\";\nimport { CommandSocketIdentity } from \"../schema/command-socket-identity\";\nimport { BuiltinCommandSet } from \"../builtin/builtin-command-set\";\nimport { CommandSocketError } from \"../error/command-socket-error\";\nimport { CommandSocketCommandNotFoundError } from \"../error/command-socket-command-not-found-error\";\nimport { CommandSocketServerError } from \"../error/command-socket-server-error\";\nimport { CommandSocketMisplacedResponseError } from \"../error/command-socket-misplaced-response-error\";\nimport { ISocket } from \"../socket/i-socket\";\nimport { IdentifyCommand } from \"../builtin/commands/identify-command\";\nimport { PingCommand } from \"../builtin/commands/ping-command\";\nimport { CommandSocketEvents } from \"./command-socket-events\";\nimport { CommandSocketState } from \"./command-socket-state\";\nimport { TimedResponseCommand } from \"../builtin/commands/debug/timed-response-command\";\nimport { FormalCommand } from \"../schema/command/formal-command\";\nimport { CommandSocketUnrequitedRequestError } from \"../error/command-socket-unrequited-request-error\";\nimport { CommandStructureParameterType, CommandStructureReturnType } from \"../schema/command/command-structure\";\n\ntype ResponseCallback<T = any> = (response: CommandSocketResponseMessage, timeReceived: number) => void;\n\ntype OutstandingRequest<T = any> = {\n\t\n\trequest: CommandSocketRequestMessage,\n\tresponseCallback: ResponseCallback<T>\n\t\n};\n\nexport type FullCommandSet<CS extends CommandSetStructure> = CS & BuiltinCommandSet;\n\ntype ParameterOf<CS extends CommandSetStructure, CN extends CommandNameInCommandSet<CS> =\n\tCommandNameInCommandSet<CS>> =\n\tCommandStructureParameterType<CommandStructureInCommandSet<CS, CN>>;\n\ntype ReturnTypeOf<CS extends CommandSetStructure, CN extends CommandNameInCommandSet<CS> =\n\tCommandNameInCommandSet<CS>> =\n\tCommandStructureReturnType<CommandStructureInCommandSet<CS, CN>>;\n\n/**\n * The underlying 'pure' connection between a client and server or vice-versa.\n *\n * Generic arguments:\n *   LCS - Local CommandSetStructure\n *   RCS - Remote CommandSetStructure\n *\n * @author Trevor Sears <trevorsears.main@gmail.com>\n * @version v0.1.0\n * @since v0.1.0\n * @param LCS The local command set - must implement {@link CommandSetStructure}.\n */\nexport abstract class CommandSocket<\n\tLCS extends CommandSetStructure = any,\n\tRCS extends CommandSetStructure = any> { // TODO [2/21/20 @ 2:56 PM] - Remove default generic types.\n\t\n\t/**\n\t * The length of the ID generated for each new CommandSocket.\n\t */\n\tpublic static readonly ID_LENGTH: number = 10;\n\t\n\t/**\n\t * An array of {@link Command}s that come built-in with each CommandSocket.\n\t */\n\tprivate static readonly BUILTIN_COMMANDS: { [commandName: string]: FormalCommand<any> } = {\n\t\t\"commandsocket identify\": new IdentifyCommand(),\n\t\t\"commandsocket ping\": new PingCommand(),\n\t\t\"commandsocket debug timed-response\": new TimedResponseCommand()\n\t};\n\t\n\t/**\n\t * The internal ISocket-conforming instance used internally to communicate with other CommandSockets.\n\t */\n\tprivate socket: ISocket;\n\t\n\t// DOC-ME [2/21/20 @ 4:36 PM] - Documentation required!\n\tprivate state: CommandSocketState;\n\t\n\t// DOC-ME [2/21/20 @ 4:36 PM] - Documentation required!\n\tprivate id: string;\n\t\n\t// DOC-ME [2/21/20 @ 4:36 PM] - Documentation required!\n\tprivate commandRegistry: CommandRegistry<FullCommandSet<LCS>>;\n\t\n\t// DOC-ME [2/21/20 @ 4:36 PM] - Documentation required!\n\tprivate messageType: ObjectType;\n\t\n\t// DOC-ME [2/21/20 @ 4:36 PM] - Documentation required!\n\tprivate outstandingRequests: Map<string, OutstandingRequest>;\n\t\n\t// DOC-ME [2/21/20 @ 4:36 PM] - Documentation required!\n\tprivate events: CommandSocketEvents;\n\t\n\tpublic constructor(socket: ISocket, commandRegistry: CommandRegistry<LCS> = new CommandRegistry<LCS>()) {\n\t\n\t\tthis.id = IDUtilities.generateID(CommandSocket.ID_LENGTH);\n\t\tthis.socket = socket;\n\t\tthis.state = CommandSocketState.CONNECTING;\n\t\tthis.commandRegistry = commandRegistry as unknown as CommandRegistry<FullCommandSet<LCS>>;\n\t\tthis.messageType = new ObjectType(new MessageDefinition());\n\t\tthis.outstandingRequests = new Map();\n\t\tthis.events = new CommandSocketEvents();\n\t\t\n\t\tthis.socket.getEvents().OPEN.subscribe((event: { source: ISocket }): void => {\n\t\t\t\n\t\t\tthis.state = CommandSocketState.OPEN;\n\t\t\t\n\t\t\tthis.getEvents().OPEN.notify({ source: this });\n\t\t\t\n\t\t\t// In-case a handshake is ever needed, perform it here.\n\t\t\t// this.invoke(\"commandsocket handshake\");\n\t\t\t\n\t\t});\n\t\t\n\t\tthis.socket.getEvents().MESSAGE.subscribe((event: { source: ISocket, data: any }): void => {\n\t\t\t\n\t\t\tthis.handleMessage(event.data);\n\t\t\n\t\t});\n\t\t\n\t\tthis.socket.getEvents().CLOSE.subscribe((event: { source: ISocket, code: number, reason: string }): void => {\n\t\t\t\n\t\t\tthis.state = CommandSocketState.CLOSED;\n\t\t\t\n\t\t\tthis.getEvents().CLOSE.notify({ ...event, source: this });\n\t\t\t\n\t\t});\n\t\t\n\t\tfor (let commandName in CommandSocket.BUILTIN_COMMANDS) {\n\t\t\t\n\t\t\tthis.getCommandRegistry().addCommand(commandName as any, CommandSocket.BUILTIN_COMMANDS[commandName]);\n\t\t\t\n\t\t}\n\t\t\n\t\t// TODO [10/20/19 @ 10:23 PM] - Implement 'error', 'ping', etc events.\n\t\n\t}\n\t\n\t/**\n\t * Asynchronously executes a command on the remote CommandSocket, returning a Promise that resolves to the entire\n\t * JSON message ({@link CommandSocketResponseMessage}) returned from said CommandSocket.\n\t *\n\t * @param command The string Command identifier of the Command to be executed.\n\t * @param params The parameter(s) to pass to the Command to be executed.\n\t * @return A Promise that resolves to the entire JSON message (CommandSocketResponseMessage) returned from the\n\t * remote CommandSocket.\n\t * @see CommandSocket#invoke\n\t */\n\tpublic async rawRequest<CommandName extends CommandNameInCommandSet<FullCommandSet<RCS>>>(\n\t\tcommand: CommandName,\n\t\tparams: ParameterOf<FullCommandSet<RCS>, CommandName>):\n\t\tPromise<CommandSocketResponseMessage<CommandStructureInCommandSet<FullCommandSet<RCS>, CommandName>>> {\n\t\t\n\t\ttype CommandSocketResponse = CommandSocketResponseMessage<CommandStructureInCommandSet<FullCommandSet<RCS>, CommandName>>;\n\t\ttype RawRequestPromiseResolveType = PromiseLike<CommandSocketResponse> | CommandSocketResponse;\n\t\t\n\t\t// TODO [11/26/19 @ 2:12 AM] - Add error when invoking on closed CommandSocket.\n\t\t\n\t\treturn new Promise<CommandSocketResponse>(async (resolve: (value?: RawRequestPromiseResolveType) => void, reject: (reason?: any) => void): Promise<void> => {\n\t\t\t\t\n\t\t\t\t// TODO [11/27/19 @ 1:04 AM] - Respond with an actual error instead, whatever is used in a CommandSocketResponseMessage.\n\t\t\t\tif (!this.getState().isUsable()) reject(\"Cannot perform a request on a non-open CommandSocket.\");\n\t\t\t\t\n\t\t\t\tlet request: CommandSocketRequestMessage<CommandStructureInCommandSet<FullCommandSet<RCS>, CommandName>> =\n\t\t\t\t\tawait CommandSocketMessageFactory.createRequestMessage<CommandStructureInCommandSet<FullCommandSet<RCS>, CommandName>>(\n\t\t\t\t\t\tcommand as string,\n\t\t\t\t\t\tparams,\n\t\t\t\t\t\tthis\n\t\t\t\t\t);\n\t\t\t\t\n\t\t\t\tthis.outstandingRequests.set(\n\t\t\t\t\trequest.meta.correspondenceID,\n\t\t\t\t\t{\n\t\t\t\t\t\trequest,\n\t\t\t\t\t\tresponseCallback: (response: CommandSocketResponseMessage<CommandStructureInCommandSet<FullCommandSet<RCS>, CommandName>>, timeReceived: number): void => {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tresponse.meta.timeline.responseReceived = timeReceived;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tthis.getEvents().REQUEST_FULFILLED.notify({\n\t\t\t\t\t\t\t\tsource: this,\n\t\t\t\t\t\t\t\trequest,\n\t\t\t\t\t\t\t\tresponse\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tthis.outstandingRequests.delete(request.meta.correspondenceID);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tresolve(response);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\n\t\t\t\tthis.getEvents().OUTGOING_REQUEST.notify({ source: this, request });\n\t\t\t\t\n\t\t\t\tthis.socket.send(JSON.stringify(request));\n\t\t\t\t\n\t\t\t}\n\t\t);\n\t\t\n\t}\n\t\n\t/**\n\t * Asynchronously executes a command on the remote CommandSocket, returning a Promise that resolves to the return\n\t * value of the executed Command.\n\t *\n\t * @param command The string Command identifier of the Command to be executed.\n\t * @param params The parameter(s) to pass to the Command to be executed.\n\t * @return A Promise which resolves to the return value of the executed Command.\n\t */\n\tpublic async invoke<CommandName extends CommandNameInCommandSet<FullCommandSet<RCS>>>(\n\t\tcommand: CommandName, params: ParameterOf<FullCommandSet<RCS>, CommandName>): Promise<ReturnTypeOf<FullCommandSet<RCS>, CommandName>> {\n\t\t\n\t\t// TODO [11/26/19 @ 2:12 AM] - Add error when invoking on closed CommandSocket.\n\t\n\t\tlet response: CommandSocketResponseMessage<CommandStructureInCommandSet<FullCommandSet<RCS>, CommandName>> = await this.rawRequest(command, params);\n\t\t\n\t\tif (response.meta.didError) throw response.return;\n\t\telse return response.return as ReturnTypeOf<FullCommandSet<RCS>, CommandName>;\n\t\n\t}\n\t\n\tpublic async ping(): Promise<number> {\n\t\t\n\t\t// FIX-ME [2/21/20 @ 10:12 PM] - The type coercions in the next line are gross\n\t\tlet response: CommandSocketResponseMessage<CommandStructureInCommandSet<FullCommandSet<RCS>, \"commandsocket ping\">> =\n\t\t\tawait this.rawRequest(\"commandsocket ping\" as any, \"Ping!\" as any);\n\t\t\n\t\treturn ((response.meta.timeline.responseReceived as number) - response.meta.timeline.requestSent);\n\t\t\n\t}\n\t\n\tpublic async close(): Promise<void> {\n\t\n\t\t// TODO [10/29/19 @ 8:22 PM] - Respond to all outstanding requests with some form of an Error.\n\t\t\n\t\tlet timestamp: number = Date.now();\n\t\t\n\t\tfor (let outstandingRequest of this.outstandingRequests.values()) {\n\t\t\n\t\t\tlet response: CommandSocketResponseMessage = await CommandSocketMessageFactory.createResponseMessage(\n\t\t\t\toutstandingRequest.request,\n\t\t\t\tnew CommandSocketUnrequitedRequestError(),\n\t\t\t\tthis,\n\t\t\t\ttrue,\n\t\t\t\ttimestamp\n\t\t\t);\n\t\t\t\n\t\t\t// TODO [11/27/19 @ 1:18 AM] - We need to make an error that fits what's going on here for the above function call (2nd arg: CommandSocketError).\n\t\t\t\n\t\t\toutstandingRequest.responseCallback(response, timestamp);\n\t\t\n\t\t}\n\t\t\n\t\tthis.outstandingRequests.clear();\n\t\t\n\t\tthis.socket.close();\n\t\n\t}\n\t\n\tprotected handleMessage(data: any): void {\n\t\t\n\t\tlet timeReceived: number = Date.now();\n\t\tlet jsonData: any;\n\t\t\n\t\ttry {\n\t\t\t\n\t\t\tjsonData = JSON.parse(data);\n\t\t\t\n\t\t\tif (!this.messageType.checkConformity(jsonData)) {\n\t\t\t\t\n\t\t\t\t/* If a proper response can be formulated (if the data object has a correspondenceID) then reply with an\n\t\t\t\t * error, then close.\n\t\t\t\t * Otherwise, just close.\n\t\t\t\t * Make sure to include a proper error code and 'reason' string.\n\t\t\t\t */\n\t\t\t\t\n\t\t\t\t// TODO [10/29/19 @ 4:03 PM] - Finish the full MalformedMessageError class and throw an instance here.\n\t\t\t\tthrow new Error(\"MalformedMessageError\");\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tlet message: CommandSocketMessage = jsonData;\n\t\t\t\n\t\t\tif (message.meta.mode === \"request\") this.handleRequest(message as CommandSocketRequestMessage, timeReceived);\n\t\t\telse this.handleResponse(message as CommandSocketResponseMessage, timeReceived);\n\t\t\t\n\t\t} catch (exception) {\n\t\t\t\n\t\t\t// Rethrow the error.\n\t\t\tthrow new Error(\"MalformedMessageError\");\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n\tprotected async handleRequest(request: CommandSocketRequestMessage, timeReceived: number): Promise<void> {\n\t\t\n\t\tlet response: CommandSocketResponseMessage;\n\t\t\n\t\tthis.getEvents().INCOMING_REQUEST.notify({ source: this, request });\n\t\t\n\t\ttry {\n\t\t\t\n\t\t\tif (this.getCommandRegistry().hasCommand(request.command)) {\n\t\t\t\t\n\t\t\t\tlet returnValue: any = await this.getCommandRegistry().execute(request.command as any, request.parameters as any, this);\n\t\t\t\t\n\t\t\t\tresponse = await CommandSocketMessageFactory.createResponseMessage(request, returnValue, this, false, timeReceived);\n\t\t\t\t\n\t\t\t} else response = await (new CommandSocketCommandNotFoundError(request.command)).toMessage(request, this);\n\t\t\t\n\t\t} catch (error) {\n\t\t\t\n\t\t\tif (error instanceof CommandSocketError) response = await error.toMessage(request, this);\n\t\t\telse response = await (new CommandSocketServerError()).toMessage(request, this);\n\t\t\t\n\t\t}\n\t\t\n\t\tthis.getEvents().OUTGOING_RESPONSE.notify({ source: this, request, response });\n\t\t\n\t\tthis.socket.send(JSON.stringify(response));\n\t\t\n\t}\n\t\n\tprotected handleResponse(response: CommandSocketResponseMessage, timeReceived: number): void {\n\t\t\n\t\tif (this.outstandingRequests.has(response.meta.correspondenceID)) {\n\t\t\t\n\t\t\t// Get the outstanding request from the map.\n\t\t\tlet outstandingRequest: OutstandingRequest =\n\t\t\t\tthis.outstandingRequests.get(response.meta.correspondenceID) as OutstandingRequest;\n\t\t\t\n\t\t\t// Delete the outstanding request -- its no longer outstanding.\n\t\t\tthis.outstandingRequests.delete(response.meta.correspondenceID);\n\t\t\t\n\t\t\tthis.getEvents().INCOMING_RESPONSE.notify({\n\t\t\t\tsource: this,\n\t\t\t\trequest: outstandingRequest.request,\n\t\t\t\tresponse\n\t\t\t});\n\t\t\t\n\t\t\toutstandingRequest.responseCallback(response, timeReceived);\n\t\t\t\n\t\t} else {\n\t\t\t\n\t\t\t// We want to print out the error to the CommandSocket's stderr, but we don't want to interrupt execution.\n\t\t\tconsole.error(new CommandSocketMisplacedResponseError());\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n\tpublic getID(): string {\n\t\n\t\treturn this.id;\n\t\n\t}\n\t\n\tpublic getCommandRegistry(): CommandRegistry<LCS & BuiltinCommandSet> {\n\t\t\n\t\treturn this.commandRegistry;\n\t\t\n\t}\n\t\n\tpublic async getSocketIdentity(): Promise<CommandSocketIdentity> {\n\t\t\n\t\treturn {\n\t\t\t\n\t\t\tid: this.getID(),\n\t\t\tip: await this.socket.getIP()\n\t\t\t\n\t\t};\n\t\t\n\t}\n\t\n\tpublic getState(): CommandSocketState {\n\t\t\n\t\treturn this.state;\n\t\t\n\t}\n\t\n\tpublic getEvents(): CommandSocketEvents {\n\t\t\n\t\treturn this.events;\n\t\t\n\t}\n\t\n}"]}