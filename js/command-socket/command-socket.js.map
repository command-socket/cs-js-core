{"version":3,"sources":["ts/command-socket/command-socket.ts"],"names":["typit_1","require","IDUtilities","__importStar","command_registry_1","message_definition_1","command_socket_message_factory_1","command_socket_error_1","command_socket_command_not_found_error_1","command_socket_server_error_1","command_socket_misplaced_response_error_1","identify_command_1","ping_command_1","command_socket_events_1","command_socket_state_1","timed_response_command_1","command_socket_unrequited_request_error_1","CommandSocket","[object Object]","socket","commandRegistry","CommandRegistry","this","id","generateID","ID_LENGTH","state","CommandSocketState","CONNECTING","messageType","ObjectType","MessageDefinition","outstandingRequests","Map","events","CommandSocketEvents","getEvents","OPEN","subscribe","event","notify","source","MESSAGE","handleMessage","data","CLOSE","CLOSED","Object","assign","addCommands","BUILTIN_COMMANDS","command","params","Promise","resolve","reject","__awaiter","getState","isUsable","request","CommandSocketMessageFactory","createRequestMessage","undefined","set","meta","correspondenceID","responseCallback","response","timeReceived","timeline","responseReceived","REQUEST_FULFILLED","delete","OUTGOING_REQUEST","send","JSON","stringify","rawRequest","didError","return","requestSent","timestamp","Date","now","outstandingRequest","values","createResponseMessage","CommandSocketUnrequitedRequestError","clear","close","jsonData","parse","checkConformity","Error","message","mode","handleRequest","handleResponse","exception","INCOMING_REQUEST","getCommandRegistry","hasCommand","returnValue","execute","parameters","CommandSocketCommandNotFoundError","toMessage","error","CommandSocketError","CommandSocketServerError","OUTGOING_RESPONSE","has","get","INCOMING_RESPONSE","console","CommandSocketMisplacedResponseError","getID","ip","getIP","exports","IdentifyCommand","PingCommand","TimedResponseCommand"],"mappings":"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","file":"command-socket.js","sourcesContent":["/*\n *\tCreated by Trevor Sears <trevorsears.main@gmail.com>.\n *\t7:51 PM -- September 18th, 2019.\n *\tProject: @command-socket/core\n */\n\nimport { ObjectType } from \"typit\";\nimport * as IDUtilities from \"../util/id-utilities\";\nimport {\n\tCommandSetStructure,\n\tFullCommandSet,\n\tCommandIn,\n\tParamTypeFor,\n\tReturnTypeFor\n} from \"../schema/command-set-structure\";\nimport { CommandRegistry } from \"../command/command-registry\";\nimport { MessageDefinition } from \"../schema/typing/message-definition\";\nimport {\n\tCommandSocketMessage,\n\tCommandSocketRequestMessage,\n\tCommandSocketResponseMessage\n} from \"../schema/message/command-socket-message\";\nimport { CommandSocketMessageFactory } from \"../schema/message/command-socket-message-factory\";\nimport { CommandSocketIdentity } from \"../schema/command-socket-identity\";\nimport { BuiltinCommandSet } from \"../builtin/builtin-command-set\";\nimport { CommandSocketError } from \"../error/command-socket-error\";\nimport { CommandSocketCommandNotFoundError } from \"../error/command-socket-command-not-found-error\";\nimport { CommandSocketServerError } from \"../error/command-socket-server-error\";\nimport { CommandSocketMisplacedResponseError } from \"../error/command-socket-misplaced-response-error\";\nimport { ISocket } from \"../socket/i-socket\";\nimport { IdentifyCommand } from \"../builtin/commands/identify-command\";\nimport { PingCommand } from \"../builtin/commands/ping-command\";\nimport { CommandSocketEvents } from \"./command-socket-events\";\nimport { CommandSocketState } from \"./command-socket-state\";\nimport { TimedResponseCommand } from \"../builtin/commands/debug/timed-response-command\";\nimport { Command } from \"../command/command\";\nimport { CommandSocketUnrequitedRequestError } from \"../error/command-socket-unrequited-request-error\";\n\ntype ResponseCallback<T = any> = (response: CommandSocketResponseMessage, timeReceived: number) => void;\n\ntype OutstandingRequest<T = any> = {\n\t\n\trequest: CommandSocketRequestMessage<any, T>,\n\tresponseCallback: ResponseCallback<T>\n\t\n};\n\n/**\n * The underlying 'pure' connection between a client and server or vice-versa.\n *\n * Generic arguments:\n *   LCS - Local CommandSet\n *   RCS - Remote CommandSet\n *\n * @author Trevor Sears <trevorsears.main@gmail.com>\n * @version v0.1.0\n * @since v0.1.0\n */\nexport abstract class CommandSocket<\n\tLCS extends CommandSetStructure = any,\n\tRCS extends CommandSetStructure = any> {\n\t\n\tpublic static readonly ID_LENGTH: number = 10;\n\t\n\tprivate static readonly BUILTIN_COMMANDS: Array<Command<any, any>> = [\n\t\tnew IdentifyCommand(),\n\t\tnew PingCommand(),\n\t\tnew TimedResponseCommand()\n\t];\n\t\n\tprivate socket: ISocket;\n\t\n\tprivate state: CommandSocketState;\n\t\n\tprivate id: string;\n\t\n\tprivate commandRegistry: CommandRegistry<FullCommandSet<LCS>>;\n\t\n\tprivate messageType: ObjectType;\n\t\n\tprivate outstandingRequests: Map<string, OutstandingRequest>;\n\t\n\tprivate events: CommandSocketEvents;\n\t\n\tpublic constructor(socket: ISocket,\n\t\t\t\t\t   commandRegistry: CommandRegistry<FullCommandSet<LCS>> = new CommandRegistry<FullCommandSet<LCS>>()) {\n\t\n\t\tthis.id = IDUtilities.generateID(CommandSocket.ID_LENGTH);\n\t\tthis.socket = socket;\n\t\tthis.state = CommandSocketState.CONNECTING;\n\t\tthis.commandRegistry = commandRegistry;\n\t\tthis.messageType = new ObjectType(new MessageDefinition());\n\t\tthis.outstandingRequests = new Map();\n\t\tthis.events = new CommandSocketEvents();\n\t\t\n\t\tthis.socket.getEvents().OPEN.subscribe((event: { source: ISocket }): void => {\n\t\t\t\n\t\t\tthis.state = CommandSocketState.OPEN;\n\t\t\t\n\t\t\tthis.getEvents().OPEN.notify({ source: this });\n\t\t\t\n\t\t\t// In-case a handshake is ever needed, perform it here.\n\t\t\t// this.invoke(\"commandsocket handshake\");\n\t\t\t\n\t\t});\n\t\t\n\t\tthis.socket.getEvents().MESSAGE.subscribe((event: { source: ISocket, data: any }): void => {\n\t\t\t\n\t\t\tthis.handleMessage(event.data);\n\t\t\n\t\t});\n\t\t\n\t\tthis.socket.getEvents().CLOSE.subscribe((event: { source: ISocket, code: number, reason: string }): void => {\n\t\t\t\n\t\t\tthis.state = CommandSocketState.CLOSED;\n\t\t\t\n\t\t\tthis.getEvents().CLOSE.notify({ ...event, source: this });\n\t\t\t\n\t\t});\n\t\t\n\t\tthis.commandRegistry.addCommands(...CommandSocket.BUILTIN_COMMANDS);\n\t\t\n\t\t// TODO [10/20/19 @ 10:23 PM] - Implement 'error', 'ping', etc events.\n\t\n\t}\n\t\n\tpublic async rawRequest<C extends CommandIn<RCS> = CommandIn<RCS>>(command: C, params?: ParamTypeFor<RCS, C>): Promise<CommandSocketResponseMessage> {\n\t\t\n\t\t// TODO [11/26/19 @ 2:12 AM] - Add error when invoking on closed CommandSocket.\n\t\t\n\t\treturn new Promise<CommandSocketResponseMessage>(\n\t\t\tasync (resolve: (value?: (PromiseLike<CommandSocketResponseMessage> | CommandSocketResponseMessage)) => void,\n\t\t\t\t   reject: (reason?: any) => void): Promise<void> => {\n\t\t\t\t\n\t\t\t\t// TODO [11/27/19 @ 1:04 AM] - Respond with an actual error instead, whatever is used in a CommandSocketResponseMessage.\n\t\t\t\tif (!this.getState().isUsable()) reject(\"Cannot perform a request on a non-open CommandSocket.\");\n\t\t\t\t\n\t\t\t\tlet request: CommandSocketRequestMessage<ParamTypeFor<RCS, C>, ReturnTypeFor<RCS, C>> =\n\t\t\t\t\tawait CommandSocketMessageFactory.createRequestMessage<ParamTypeFor<RCS, C>, ReturnTypeFor<RCS, C>>(\n\t\t\t\t\t\tcommand as string,\n\t\t\t\t\t\t(params === undefined ? null : params),\n\t\t\t\t\t\tthis\n\t\t\t\t\t);\n\t\t\t\t\n\t\t\t\tthis.outstandingRequests.set(\n\t\t\t\t\trequest.meta.correspondenceID,\n\t\t\t\t\t{\n\t\t\t\t\t\trequest,\n\t\t\t\t\t\tresponseCallback: (response: CommandSocketResponseMessage, timeReceived: number): void => {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tresponse.meta.timeline.responseReceived = timeReceived;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tthis.getEvents().REQUEST_FULFILLED.notify({\n\t\t\t\t\t\t\t\tsource: this,\n\t\t\t\t\t\t\t\trequest,\n\t\t\t\t\t\t\t\tresponse\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tthis.outstandingRequests.delete(request.meta.correspondenceID);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tresolve(response);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\n\t\t\t\tthis.getEvents().OUTGOING_REQUEST.notify({ source: this, request });\n\t\t\t\t\n\t\t\t\tthis.socket.send(JSON.stringify(request));\n\t\t\t\t\n\t\t\t}\n\t\t);\n\t\t\n\t}\n\t\n\tpublic async invoke<C extends CommandIn<RCS> = CommandIn<RCS>>(command: C, params?: ParamTypeFor<RCS, C>): Promise<ReturnTypeFor<RCS, C>> {\n\t\t\n\t\t// TODO [11/26/19 @ 2:12 AM] - Add error when invoking on closed CommandSocket.\n\t\n\t\tlet response: CommandSocketResponseMessage = await this.rawRequest(command, params);\n\t\t\n\t\tif (response.meta.didError) throw response.return;\n\t\telse return response.return;\n\t\n\t}\n\t\n\tpublic async ping(): Promise<number> {\n\t\t\n\t\tlet response: CommandSocketResponseMessage = await this.rawRequest(\"commandsocket ping\", \"Ping!\");\n\t\t\n\t\treturn ((response.meta.timeline.responseReceived as number) - response.meta.timeline.requestSent);\n\t\t\n\t}\n\t\n\tpublic async close(): Promise<void> {\n\t\n\t\t// TODO [10/29/19 @ 8:22 PM] - Respond to all outstanding requests with some form of an Error.\n\t\t\n\t\tlet timestamp: number = Date.now();\n\t\t\n\t\tfor (let outstandingRequest of this.outstandingRequests.values()) {\n\t\t\n\t\t\tlet response: CommandSocketResponseMessage = await CommandSocketMessageFactory.createResponseMessage(\n\t\t\t\toutstandingRequest.request,\n\t\t\t\tnew CommandSocketUnrequitedRequestError(),\n\t\t\t\tthis,\n\t\t\t\ttrue,\n\t\t\t\ttimestamp\n\t\t\t);\n\t\t\t\n\t\t\t// TODO [11/27/19 @ 1:18 AM] - We need to make an error that fits what's going on here for the above function call (2nd arg: CommandSocketError).\n\t\t\t\n\t\t\toutstandingRequest.responseCallback(response, timestamp);\n\t\t\n\t\t}\n\t\t\n\t\tthis.outstandingRequests.clear();\n\t\t\n\t\tthis.socket.close();\n\t\n\t}\n\t\n\tprotected handleMessage(data: any): void {\n\t\t\n\t\tlet timeReceived: number = Date.now();\n\t\tlet jsonData: any;\n\t\t\n\t\ttry {\n\t\t\t\n\t\t\tjsonData = JSON.parse(data);\n\t\t\t\n\t\t\tif (!this.messageType.checkConformity(jsonData)) {\n\t\t\t\t\n\t\t\t\t/* If a proper response can be formulated (if the data object has a correspondenceID) then reply with an\n\t\t\t\t * error, then close.\n\t\t\t\t * Otherwise, just close.\n\t\t\t\t * Make sure to include a proper error code and 'reason' string.\n\t\t\t\t */\n\t\t\t\t\n\t\t\t\t// TODO [10/29/19 @ 4:03 PM] - Finish the full MalformedMessageError class and throw an instance here.\n\t\t\t\tthrow new Error(\"MalformedMessageError\");\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tlet message: CommandSocketMessage = jsonData;\n\t\t\t\n\t\t\tif (message.meta.mode === \"request\") this.handleRequest(message as CommandSocketRequestMessage, timeReceived);\n\t\t\telse this.handleResponse(message as CommandSocketResponseMessage, timeReceived);\n\t\t\t\n\t\t} catch (exception) {\n\t\t\t\n\t\t\t// Rethrow the error.\n\t\t\tthrow new Error(\"MalformedMessageError\");\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n\tprotected async handleRequest(request: CommandSocketRequestMessage, timeReceived: number): Promise<void> {\n\t\t\n\t\tlet response: CommandSocketResponseMessage;\n\t\t\n\t\tthis.getEvents().INCOMING_REQUEST.notify({ source: this, request });\n\t\t\n\t\ttry {\n\t\t\t\n\t\t\tif (this.getCommandRegistry().hasCommand(request.command)) {\n\t\t\t\t\n\t\t\t\tlet returnValue: any = await this.getCommandRegistry().execute(request.command, request.parameters, this);\n\t\t\t\t\n\t\t\t\tresponse = await CommandSocketMessageFactory.createResponseMessage(request, returnValue, this, false, timeReceived);\n\t\t\t\t\n\t\t\t} else response = await (new CommandSocketCommandNotFoundError(request.command)).toMessage(request, this);\n\t\t\t\n\t\t} catch (error) {\n\t\t\t\n\t\t\tif (error instanceof CommandSocketError) response = await error.toMessage(request, this);\n\t\t\telse response = await (new CommandSocketServerError()).toMessage(request, this);\n\t\t\t\n\t\t}\n\t\t\n\t\tthis.getEvents().OUTGOING_RESPONSE.notify({ source: this, request, response });\n\t\t\n\t\tthis.socket.send(JSON.stringify(response));\n\t\t\n\t}\n\t\n\tprotected handleResponse(response: CommandSocketResponseMessage, timeReceived: number): void {\n\t\t\n\t\tif (this.outstandingRequests.has(response.meta.correspondenceID)) {\n\t\t\t\n\t\t\t// Get the outstanding request from the map.\n\t\t\tlet outstandingRequest: OutstandingRequest =\n\t\t\t\tthis.outstandingRequests.get(response.meta.correspondenceID) as OutstandingRequest;\n\t\t\t\n\t\t\t// Delete the outstanding request -- its no longer outstanding.\n\t\t\tthis.outstandingRequests.delete(response.meta.correspondenceID);\n\t\t\t\n\t\t\tthis.getEvents().INCOMING_RESPONSE.notify({\n\t\t\t\tsource: this,\n\t\t\t\trequest: outstandingRequest.request,\n\t\t\t\tresponse\n\t\t\t});\n\t\t\t\n\t\t\toutstandingRequest.responseCallback(response, timeReceived);\n\t\t\t\n\t\t} else {\n\t\t\t\n\t\t\t// We want to print out the error to the CommandSocket's stderr, but we don't want to interrupt execution.\n\t\t\tconsole.error(new CommandSocketMisplacedResponseError());\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n\tpublic getID(): string {\n\t\n\t\treturn this.id;\n\t\n\t}\n\t\n\tpublic getCommandRegistry(): CommandRegistry<LCS & BuiltinCommandSet> {\n\t\t\n\t\treturn this.commandRegistry;\n\t\t\n\t}\n\t\n\tpublic async getSocketIdentity(): Promise<CommandSocketIdentity> {\n\t\t\n\t\treturn {\n\t\t\t\n\t\t\tid: this.getID(),\n\t\t\tip: await this.socket.getIP()\n\t\t\t\n\t\t};\n\t\t\n\t}\n\t\n\tpublic getState(): CommandSocketState {\n\t\t\n\t\treturn this.state;\n\t\t\n\t}\n\t\n\tpublic getEvents(): CommandSocketEvents {\n\t\t\n\t\treturn this.events;\n\t\t\n\t}\n\t\n}"]}